\documentclass{article}
\usepackage[UTF8]{ctex} 
\usepackage{amsmath}
\usepackage{bm}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric}
\usetikzlibrary{decorations.pathreplacing, fit}
\geometry{a4paper, margin=1.5cm}

\title{多维数组和字符串}
\author{Tan Yiqing}
\date{\today}

\begin{document}
\maketitle
    
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.85\textwidth]{"D:/program/data_construction/firefly/d96f8fc028d14459672dc2f6df4d3383.jpg"}
    \end{figure}

\section{多维数组}
\indent 多维数组是由多个一维数组组成的数组。最常见的就是二维数组，可以看作是一个表格，具有行和列。
上述的矩阵可以看做一个线性表，每个元素是矩阵的一行，把每行的元素用一个线性表装起来。
同理可以推广到多维数组。
\subsection{数组的定义}
\indent 数组是由一组类型相同的数据元素构成的有序集合，每个数据元素称为一个数组元素，
受 n 个线性关系的约束。我们使用 n 个序号来描述每个元素的位置。
\subsection{数组的基本操作}
数组的基本操作包括：
\begin{itemize}
    \item 存取元素：给定下标，读出数组中的元素。
    \item 修改元素：给定下标，修改数组中的元素。
    \item 上述称寻址类操作，数组使用顺序结构储存。
\end{itemize}
\subsection{数组的存储结构}
n维数组内存还是一维数组，二维数组可按先行后列来储存。

\section{特殊矩阵}
\indent 一般来说一个$m*n$的矩阵需要$m*n$的空间来存储，但是有些矩阵有特殊的性质，可以节省空间。
基本思路是相同元素只记一个，0可以不记。
\subsection{对称矩阵}

\subsection{上三角矩阵和下三角矩阵}

\subsection{三对角矩阵：川形矩阵}

\subsection{稀疏矩阵：很多0的矩阵}
\indent 稀疏矩阵是指矩阵中大部分元素为0的矩阵。稀疏矩阵可以用三元组顺序表来存储。
\begin{itemize}
    \item 三元组顺序表：用一个三元组（行号，列号，值）来表示矩阵中的非零元素。
    \item 例如：
    \[
        \begin{bmatrix}
            0 & 0 & 3 & 0 \\
            0 & 0 & 5 & 7 \\
            0 & 0 & 0 & 0 \\
            0 & 2 & 6 & 0
        \end{bmatrix}
    \]
    可以表示为：
    \[
        \begin{bmatrix}
            (1,3,3) (2,3,5) (2,4,7) (4,2,2) (4,3,6)
        \end{bmatrix}
    \]
\end{itemize}
\indent 也可以用十字链表来实现。
\begin{itemize}
    \item 十字链表：每个非零元素有两个指针，一个指向同一行的下一个非零元素，一个指向同一列的下一个非零元素。
    \item 例如上面的矩阵，可以表示为：
    \[
        \begin{bmatrix}
            (1,3,3) \rightarrow (2,3,5) \rightarrow (4,3,6) \\
            (2,4,7) \\
            (4,2,2)
        \end{bmatrix}
    \]
\end{itemize}
\indent 三元组表使用的多，而且简单；十字链表写起来复杂，但是矩阵乘法操作方便。

\section{字符串}
\indent 字符串是由零个或多个字符组成的有限序列。字符个数成为字串长度，空串记为""，长度为0。
非空字串记为"$s_{0}s_{1}...s_{n-1}$"，长度为n，其中双引号为字符串的界定符。
\subsection{字符串的操作}
\subsubsection{字符串比较}
\indent 字符串比较是指比较两个字符串的大小关系。一般来说，字符串的比较是按字典序进行的。
\indent 连续的子序列均称为子串。子串的位置为其首字符于原字串的位置。
\begin{itemize}
    \item 字典序：按字符的ASCII码值逐个比较，直到遇到不同的字符为止。若一个字符串是另一个字符串的前缀，则较短的字符串较小。
    \item 例如："apple" < "banana"，因为'a' < 'b'；"apple" < "apples"，因为前者是后者的前缀。
    \item 算法：从第一个字符开始，逐个比较两个字符串的字符，直到遇到不同的字符或其中一个字符串结束为止。
\end{itemize}
\subsubsection{字符串连接}
\indent 字符串连接是指将两个字符串合并成一个新的字符串。连接符通常用"+"表示。
\begin{itemize}
    \item 例如："hello" + "world" = "helloworld"
    \item 算法：创建一个新的字符串，长度为两个字符串长度之和，然后将第一个字符串的字符复制到新字符串的前半部分，再将第二个字符串的字符复制到新字符串的后半部分。
\end{itemize}

\subsubsection{子串}
\indent 子串是指字符串中的一个连续的字符序列。子串可以通过指定起始位置和长度来获取。
\begin{itemize}
    \item 例如：字符串"hello"的子串有"he"、"ell"、"lo"等。
    \item 算法：给定起始位置和长度，从原字符串中提取相应的字符，形成新的子串。
\end{itemize}

\subsection{字符串的存储结构}
\indent c++用字符串类string来存储字符串，无需特殊处理。

\section{模式匹配:pattern matching}
\indent 模式匹配是指在一个字符串中查找另一个字符串的位置。模式匹配广泛应用于文本编辑器、搜索引擎等领域。
这里只介绍最简单的模式匹配算法。\\
\indent 给定主串S和模式串T，在S中寻找T的位置成为模式匹配问题。
若匹配成功，返回T在S中的位置；若失败，返回-1。\\
\indent 注意:算法执行一次的时间不容忽视，因此一个好的算法的长期效果不容忽视。

\subsection{BF算法：Brute Force}
\indent BF算法是最简单的模式匹配算法。对S的每个位置i，与T进行比较。当不对应时T回溯到第一个字符，继续与S的位置i+1重新开始比较。\\
\indent 它的正确率有绝对保证，但是时间复杂度为O(m*n)很高，其中m为S的长度，n为T的长度。
\begin{itemize}
    \item 算法步骤：
    \begin{enumerate}
        \item 初始化两个指针i和j，分别指向S和T的起始位置。
        \item 比较S[i]和T[j]，如果相等，则i++，j++；如果不相等，则i = i - j + 1，j = 0。
        \item 重复步骤2，直到j等于T的长度（匹配成功）或i等于S的长度（匹配失败）。
        \item 如果匹配成功，返回i - j；否则返回-1。
    \end{enumerate}
\end{itemize}


\subsection{KMP算法：Knuth-Morris-Pratt}
\indent KMP算法是改进的模式匹配算法。它利用已经匹配过的信息，避免了不必要的比较，从而提高了效率。\\
\indent 让我们先思考一个情况，设模式串abcac，假设前四位已经匹配成功了，如果kmp算法有改进，那么主串的第五位一定是a，
这就说明了模式串的前缀和后缀有相同的部分。\\
\indent 假设我们目前在配对S的第i个位置和T的第j个位置。错配后，如果应该把模式滑到T的第k个位置，那其实代表了：
\[
    T_{0}T_{1}\ldots T_{j-1} = S_{i-j}S_{i-j+1}\ldots S_{i-1}
\]
\[
    T_{0}T_{1}\ldots T_{k-1} = S_{i-k}S_{i-k+1}\ldots S_{i-1}
\]
\indent 由此我们可以推断得到：
\[
    T_{0}T_{1}\ldots T_{k-1} = T_{j-k}T_{j-k+1}\ldots T_{j-1}
\]
\indent 即T中有一部分是重复的，具体来说，是0到第k个字符和第j-k个到第j-1个字符相同。\\
\indent 对于每一个j，（如果有多个k）我们都可以找到一个最大的k，使得上述等式成立。\\
\indent KMP 算法的关键就是要知道如果在模式的第 j 个位置失配，
我们应该改变成与模式的第几个位置再进行匹配（也就是到底应该回溯多少）,
这个信息存储在一个叫做 next 数组的数组中。\\

    \begin{figure}[h]
        \centering
        \includegraphics[width=0.85\textwidth]{D:/program/data_construction/L4/理论/搜狗截图20251031185229.png}
    \end{figure}

\subsection{next数组的计算}
\indent next数组的计算是KMP算法的关键步骤。next数组用于记录模式串中每个位置的最长相等前后缀的长度。
\begin{enumerate}
    \item 初始化：$next[0]=-1$，$j=-1$。
    \item 对 $i=1,2,\ldots,n-1$ 依次执行：
        \begin{enumerate}
            \item 当 $j\ge0$ 且 $T[i]\ne T[j+1]$ 时，令 $j\leftarrow next[j]$（沿前缀函数回退）。
            \item 若此时 $T[i]=T[j+1]$，则 $j\leftarrow j+1$（成功扩展一位）。
            \item 置 $next[i]=j$。
        \end{enumerate}
\end{enumerate}

\paragraph{伪代码}
\begin{lstlisting}[frame=single]
Input: pattern T[0..n-1]
Output: next[0..n-1]   // 长度版

next[0] <- 0
j <- 0                        // 已匹配前缀长度
for i from 1 to n-1:
    while j > 0 and T[i] != T[j]:
        j <- next[j-1]
    if T[i] == T[j]:
        j <- j + 1
    next[i] <- j
\end{lstlisting}

    
\paragraph{示例：模式串 \texttt{"ABCABD"} 的跳转表构造}
\begin{enumerate}
    \item 位置0：子串 \texttt{"A"}\\
    前缀：$[\ ]$，后缀：$[\ ]$；最长公共前后缀：$0\ \Rightarrow\ $跳转值 $=0$
    \item 位置1：子串 \texttt{"AB"}\\
    前缀：$[\texttt{"A"}]$，后缀：$[\texttt{"B"}]$；无相同 $\Rightarrow$ 跳转值 $=0$
    \item 位置2：子串 \texttt{"ABC"}\\
    前缀：$[\texttt{"A"},\texttt{"AB"}]$，后缀：$[\texttt{"BC"},\texttt{"C"}]$；无相同 $\Rightarrow$ 跳转值 $=0$
    \item 位置3：子串 \texttt{"ABCA"}\\
    前缀：$[\texttt{"A"},\texttt{"AB"},\texttt{"ABC"}]$，后缀：$[\texttt{"BCA"},\texttt{"CA"},\texttt{"A"}]$；公共部分：\texttt{"A"} $\Rightarrow$ 跳转值 $=1$
    \item 位置4：子串 \texttt{"ABCAB"}\\
    前缀：$[\texttt{"A"},\texttt{"AB"},\texttt{"ABC"},\texttt{"ABCA"}]$，后缀：$[\texttt{"BCAB"},\texttt{"CAB"},\texttt{"AB"},\texttt{"B"}]$；公共部分：\texttt{"AB"} $\Rightarrow$ 跳转值 $=2$
    \item 位置5：子串 \texttt{"ABCABD"}\\
    前缀：$[\texttt{"A"},\texttt{"AB"},\texttt{"ABC"},\texttt{"ABCA"},\texttt{"ABCAB"}]$，后缀：$[\texttt{"BCABD"},\texttt{"CABD"},\texttt{"ABD"},\texttt{"BD"},\texttt{"D"}]$；无相同 $\Rightarrow$ 跳转值 $=0$
\end{enumerate}

\noindent 得到跳转表：$[-1,\,0,\,0,\,1,\,2,\,0]$。


// ...existing code...
\subsection{kmp算法的执行}
\indent 本节按“长度版”next（lps）：$next[i]$ 为 $T[0..i]$ 的最长相等真前后缀长度，$next[0]=0$。

\paragraph{执行流程}
\begin{enumerate}
    \item 设主串 $S$ 长度为 $m$，模式串 $T$ 长度为 $n$，已知 $next[0..n-1]$。
    \item 置 $i\leftarrow 0,\ j\leftarrow 0$。
    \item 当 $i<m$ 时循环：
    \begin{enumerate}
        \item 若 $j>0$ 且 $S[i]\ne T[j]$，则 $j\leftarrow next[j-1]$（回退到可重叠的最长前缀）。
        \item 若 $S[i]=T[j]$，则 $i\leftarrow i+1,\ j\leftarrow j+1$。
        \item 若 $j=n$，则在 $i-n$ 处匹配成功，记录 $i-n$；随后 $j\leftarrow next[n-1]$ 继续。
        \item 否则（无法回退且不相等时），仅 $i\leftarrow i+1$。
    \end{enumerate}
\end{enumerate}

\paragraph{伪代码（长度版）}
\begin{lstlisting}[frame=single]
Input: text S[0..m-1], pattern T[0..n-1], next[0..n-1]
Output: 所有匹配起始下标

i <- 0; j <- 0
while i < m:
    while j > 0 and S[i] != T[j]:
        j <- next[j-1]
    if S[i] == T[j]:
        i <- i + 1
        j <- j + 1
    else:
        i <- i + 1
    if j == n:
        report (i - n)
        j <- next[n-1]
\end{lstlisting}

\paragraph{示例：在 \texttt{"ABCABCABD"} 中找 \texttt{"ABCABD"}}
\indent 模式的跳转表（长度版）：$next=[-1,0,0,1,2,0]$。
\[
\text{S: }\texttt{A\ B\ C\ A\ B\ C\ A\ B\ D}\qquad
\text{T: }\texttt{A\ B\ C\ A\ B\ D}
\]
\begin{itemize}
    \item 从 $i=0,j=0$ 开始，匹配到 $i=5,j=5$ 时失配：$S[5]=\texttt{C}\ne T[5]=\texttt{D}$。
    \item 回退：$j\leftarrow next[4]=2$（$i$ 不变，仍为 5）。
    \item 继续比较：$S[5]=\texttt{C}=T[2]$，于是 $i=6,j=3$；接着
          $S[6]=\texttt{A}=T[3]$（$i=7,j=4$），
          $S[7]=\texttt{B}=T[4]$（$i=8,j=5$），
          $S[8]=\texttt{D}=T[5]$（$i=9,j=6$）。
    \item 此时 $j=n=6$，匹配成功，起始下标为 $i-n=9-6=3$（0 基）。
\end{itemize}

\noindent 说明：若以“当前比较位置”为 $i'=i-1$ 的记法，则返回 $i'-n+1=8-6+1=3$，一致。



\end{document}